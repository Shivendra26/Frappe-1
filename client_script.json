[
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Visitor Pass",
  "enabled": 1,
  "modified": "2025-09-02 17:54:37.888565",
  "module": "Visitor Pass Management",
  "name": "Visitor Pass — Walk-In UI",
  "script": "// Visitor Pass – Walk-In logic (mobile vs no-mobile) + Step B (Request Source / Authority Call)\r\n// + Pass Type auto-derivation from Valid From / Valid To\r\n// + Depth-4: Authority Call rules for registered vs unregistered\r\n// + UI Lock: Dept Admin can only edit Approver Remarks at Pending Approval\r\n\r\nfrappe.ui.form.on('Visitor Pass', {\r\n  refresh(frm) {\r\n    toggle_walkin_ui(frm);\r\n    update_pass_type_from_dates(frm);\r\n    lock_for_dept_admin(frm);               // NEW: UI lock\r\n  },\r\n\r\n  // Walk-in toggles\r\n  walk_in(frm)             { toggle_walkin_ui(frm); },\r\n  has_mobile_number(frm)   { toggle_walkin_ui(frm); },\r\n\r\n  // extra safety: re-toggle when these fields change\r\n  unregistered_walk_in(frm){ toggle_walkin_ui(frm); },\r\n  id_proof_type(frm)       { toggle_walkin_ui(frm); },\r\n  id_proof_number(frm)     { toggle_walkin_ui(frm); },\r\n\r\n  // Step B handlers\r\n  request_source(frm)      { toggle_walkin_ui(frm); },\r\n\r\n  // Depth-4: re-evaluate when a registered Visitor is linked/unlinked\r\n  visitor(frm)             { toggle_walkin_ui(frm); },\r\n\r\n  // date hooks for Pass Type\r\n  valid_from(frm)          { update_pass_type_from_dates(frm); },\r\n  valid_to(frm)            { update_pass_type_from_dates(frm); },\r\n\r\n  // Re-apply lock when workflow state changes (if you expose that field)\r\n  workflow_state(frm)      { lock_for_dept_admin(frm); },\r\n\r\n  validate(frm) {\r\n    // Only run checks for walk-ins\r\n    if (frm.doc.walk_in) {\r\n      const mustHave = [\r\n        \"has_mobile_number\",\"unregistered_walk_in\",\"mobile_no\",\r\n        \"id_proof_type\",\"id_proof_number\",\r\n        \"request_source\",\"authority_reference\",\"visitor\",\"reception_notes\"\r\n      ];\r\n      for (const f of mustHave) {\r\n        if (!frm.fields_dict[f]) {\r\n          frappe.throw(__(`Form is missing field “${f}”. Please align fieldnames in Doctype.`));\r\n        }\r\n      }\r\n\r\n      const isAuthority  = frm.doc.request_source === \"Authority Call\";\r\n      const isRegistered = !!frm.doc.visitor;\r\n      const hasMobile    = !!frm.doc.has_mobile_number;\r\n\r\n      // Reception notes are mandatory when Authority Call\r\n      if (isAuthority && !frm.doc.reception_notes) {\r\n        frappe.throw(__(\"Please fill **Reception Notes** (why this pass was created on an authority call).\"));\r\n      }\r\n\r\n      if (isAuthority) {\r\n        if (isRegistered) {\r\n          // Authority Call + registered → no extra requirements\r\n        } else {\r\n          // Authority Call + NOT registered\r\n          if (hasMobile) {\r\n            if (!frm.doc.unregistered_walk_in) {\r\n              frappe.throw(__(\"For **Authority Call** with mobile, please link **Unregistered Walk-In**.\"));\r\n            }\r\n            if (!frm.doc.mobile_no) {\r\n              frappe.throw(__(\"For **Authority Call** with mobile, please fill **Mobile No**.\"));\r\n            }\r\n          } else {\r\n            if (!frm.doc.id_proof_type || !frm.doc.id_proof_number) {\r\n              frappe.throw(__(\"For **Authority Call** without mobile, please fill **ID Proof Type** and **ID Proof Number**.\"));\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        // Self / Reception flows (Depth-2 base logic)\r\n        if (hasMobile) {\r\n          // With mobile: if visitor is NOT registered, require the pre-registration link\r\n          if (!isRegistered && !frm.doc.unregistered_walk_in) {\r\n            frappe.throw(__(\"For Walk-In **with** mobile, please fill **Unregistered Walk-In** (link).\"));\r\n          }\r\n          if (!frm.doc.mobile_no) {\r\n            frappe.throw(__(\"For Walk-In **with** mobile, please fill **Mobile No**.\"));\r\n          }\r\n        } else {\r\n          // Without mobile: require ID proof\r\n          if (!frm.doc.id_proof_type || !frm.doc.id_proof_number) {\r\n            frappe.throw(__(\"For Walk-In **without** mobile, please fill **ID Proof Type** and **ID Proof Number**.\"));\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Final guard for Pass Type from dates\r\n    if (frm.doc.valid_from && frm.doc.valid_to) {\r\n      const diff = frappe.datetime.get_day_diff(frm.doc.valid_to, frm.doc.valid_from);\r\n      if (diff < 0) {\r\n        frappe.throw(__('“Valid To” cannot be before “Valid From”.'));\r\n      }\r\n      const mustType = (diff === 0) ? get_single_day_option(frm) : get_multi_entry_option(frm);\r\n      if (frm.doc.pass_type !== mustType) {\r\n        frm.set_value('pass_type', mustType);\r\n      }\r\n    }\r\n  },\r\n});\r\n\r\n// ---- UI toggling ----\r\nfunction toggle_walkin_ui(frm) {\r\n  const isWalkIn     = !!frm.doc.walk_in;\r\n  const hasMobile    = !!frm.doc.has_mobile_number;\r\n  const isAuthority  = frm.doc.request_source === \"Authority Call\";\r\n  const isRegistered = !!frm.doc.visitor;\r\n\r\n  if (!isWalkIn) {\r\n    // turn off requirements & hide Step-B bits\r\n    set_req(frm, \"unregistered_walk_in\", false);\r\n    set_req(frm, \"mobile_no\", false);\r\n    set_req(frm, \"id_proof_type\", false);\r\n    set_req(frm, \"id_proof_number\", false);\r\n    set_req(frm, \"id_proof_attachment\", false);\r\n    // keep base fields visible for non-walk-ins as per your earlier behavior\r\n    show(frm, [\"unregistered_walk_in\",\"mobile_no\",\"id_proof_type\",\"id_proof_number\",\"id_proof_attachment\"], true);\r\n\r\n    set_req(frm, \"request_source\", false);\r\n    set_req(frm, \"authority_reference\", false);\r\n    set_req(frm, \"reception_notes\", false);\r\n    show(frm, [\"request_source\",\"authority_reference\",\"reception_notes\"], false);\r\n    frm.refresh_fields([\"request_source\",\"authority_reference\",\"reception_notes\"]);\r\n    return;\r\n  }\r\n\r\n  // --- Base visibility/requirements ---\r\n  let showIdProof = !hasMobile;\r\n  let reqIdProof  = !hasMobile;\r\n\r\n  // Link/mobile defaults\r\n  let showUnreg   = hasMobile && !isRegistered;\r\n  let reqUnreg    = hasMobile && !isRegistered;\r\n  let showMobile  = hasMobile;\r\n  let reqMobile   = hasMobile;\r\n\r\n  // Depth-4 overrides\r\n  if (isAuthority && isRegistered) {\r\n    // registered + authority → no id proof, no unregistered link, mobile optional\r\n    showIdProof = false; reqIdProof = false;\r\n    showUnreg = false;  reqUnreg  = false;\r\n    reqMobile = false;\r\n  } // (authority + not registered follows base)\r\n\r\n  // Apply ID proof visibility/requirements + attachment in sync\r\n  show(frm, [\"id_proof_type\",\"id_proof_number\",\"id_proof_attachment\"], showIdProof);\r\n  set_req(frm, \"id_proof_type\",        showIdProof && reqIdProof);\r\n  set_req(frm, \"id_proof_number\",      showIdProof && reqIdProof);\r\n  set_req(frm, \"id_proof_attachment\",  showIdProof && reqIdProof);\r\n\r\n  // Unregistered+Mobile link & Mobile no\r\n  show(frm, [\"unregistered_walk_in\"], showUnreg);\r\n  set_req(frm, \"unregistered_walk_in\", reqUnreg);\r\n\r\n  show(frm, [\"mobile_no\"], showMobile);\r\n  set_req(frm, \"mobile_no\", reqMobile);\r\n\r\n  // Request Source is always visible for Walk-In\r\n  show(frm, [\"request_source\"], true);\r\n  set_req(frm, \"request_source\", true);\r\n\r\n  if (!frm.doc.request_source) {\r\n    frm.set_value(\"request_source\", \"Self\");\r\n  }\r\n\r\n  // Authority metadata\r\n  if (isAuthority) {\r\n    show(frm, [\"authority_reference\",\"reception_notes\"], true);\r\n    set_req(frm, \"authority_reference\", true);\r\n    set_req(frm, \"reception_notes\", true);\r\n  } else {\r\n    show(frm, [\"authority_reference\",\"reception_notes\"], false);\r\n    set_req(frm, \"authority_reference\", false);\r\n    set_req(frm, \"reception_notes\", false);\r\n    if (frm.doc.authority_reference) frm.set_value(\"authority_reference\", \"\");\r\n  }\r\n\r\n  frm.refresh_fields([\r\n    \"request_source\",\"authority_reference\",\"reception_notes\",\r\n    \"unregistered_walk_in\",\"mobile_no\",\"id_proof_type\",\"id_proof_number\",\"id_proof_attachment\"\r\n  ]);\r\n}\r\n\r\n// ---- Pass Type from dates ----\r\nfunction update_pass_type_from_dates(frm) {\r\n  if (!frm.doc.valid_from || !frm.doc.valid_to) {\r\n    frm.set_df_property('pass_type', 'read_only', 0);\r\n    return;\r\n  }\r\n  const diff = frappe.datetime.get_day_diff(frm.doc.valid_to, frm.doc.valid_from);\r\n  if (diff < 0) {\r\n    frappe.msgprint(__('“Valid To” cannot be before “Valid From”.'));\r\n    frm.set_value('valid_to', '');\r\n    frm.set_df_property('pass_type', 'read_only', 0);\r\n    return;\r\n  }\r\n  const computed = (diff === 0) ? get_single_day_option(frm) : get_multi_entry_option(frm);\r\n  if (frm.doc.pass_type !== computed) frm.set_value('pass_type', computed);\r\n  frm.set_df_property('pass_type', 'read_only', 1);\r\n}\r\n\r\n// Use your exact option labels:\r\nfunction get_single_day_option(frm) { return 'Single-day'; }\r\nfunction get_multi_entry_option(frm) { return 'Multi-entry'; }\r\n\r\n// ---- UI lock for Dept Admin at Pending Approval (client-side) ----\r\nfunction lock_for_dept_admin(frm) {\r\n  // Only on Pending Approval, and only for users having the Dept Admin role\r\n  try {\r\n    const isDeptAdmin = (frappe.user_roles || frappe.user.get_roles()).includes('Dept Admin');\r\n    if (!isDeptAdmin) return;\r\n\r\n    if (frm.doc.workflow_state === 'Pending Approval') {\r\n      // Lock everything\r\n      Object.keys(frm.fields_dict).forEach(f => {\r\n        frm.set_df_property(f, 'read_only', 1);\r\n      });\r\n      // Allow only Approver Remarks to be edited\r\n      if (frm.fields_dict['approver_remarks']) {\r\n        frm.set_df_property('approver_remarks', 'read_only', 0);\r\n      }\r\n      frm.refresh_fields();\r\n    } else {\r\n      // Restore normal behavior elsewhere\r\n      Object.keys(frm.fields_dict).forEach(f => {\r\n        frm.set_df_property(f, 'read_only', 0);\r\n      });\r\n      toggle_walkin_ui(frm); // re-apply your dynamic rules\r\n    }\r\n  } catch (e) {\r\n    // If anything fails, fail safe (do nothing)\r\n    // console.log(e);\r\n  }\r\n}\r\n\r\n// ---- helpers ----\r\nfunction show(frm, fieldnames, visible) {\r\n  (Array.isArray(fieldnames) ? fieldnames : [fieldnames]).forEach(f => {\r\n    if (frm.fields_dict[f]) frm.toggle_display(f, visible);\r\n  });\r\n}\r\nfunction set_req(frm, fieldname, required) {\r\n  if (frm.fields_dict[fieldname]) {\r\n    frm.set_df_property(fieldname, \"reqd\", required ? 1 : 0);\r\n  }\r\n}\r\n",
  "view": "Form"
 }
]